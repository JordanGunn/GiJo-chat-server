////////////////////////////////////////////////////////
// PROTOCOL FAMILY CONSTANTS FOR socket() SYSTEM CALL //
////////////////////////////////////////////////////////

AF_INET             IPv4 protocols
AF_INET6            IPv6 protocols
AF_LOCAL            Unix domain protocols
AF_ROUTE            Routing sockets
AF_KEY              Key socket



////////////////////////////////////////////////////////
// PROTOCOL TYPE CONSTANTS FOR socket() SYSTEM CALL   //
////////////////////////////////////////////////////////

SOCK_STREAM         stream socket
SOCK_DGRAM          datagram socket
SOCK_SEQPACKET      sequenced packet socket
SOCK_RAW            socket



////////////////////////////////////////////////////////
// PROTOCOL OF SOCKETS FOR AF_NET AND AF_INET6        //
////////////////////////////////////////////////////////

IPPROTO_TCP         TCP transport protocol
IPPROTO_UDP         UDP transport protocol
IPPROTO_SCTP        SCTP transport protocol



////////////////////////////////////////////////////////
// connect() FUNCTION RETURN VALUE MEANINGS           //
////////////////////////////////////////////////////////

ETIMEDOUT           Client TCP received no response to its SYN segment.
ECONNREFUSED        indicates that no process is waiting for connections
                    on the server host at the port specified



////////////////////////////////////////////////////////
// fork() SYSTEM CALL                                 //
////////////////////////////////////////////////////////

-   This function returns *twice*
      1.  First in the calling process. Returns the process ID
          of newly createds process.
      2.  Also returns once in the *child process* with a value
          of 0 (zero), indicating that it is in fact the child.

-   The child fork() call returns 0 because it only has a single
    parent. The parent's process id can be obtained by calling
    getpid().

-   There is *no way* to obtain the PID of a child from the parent.
    If you wish to do this, you MUST keep track of the return values
    from the fork() call.

-   All descriptors open in the parent before the call to fork are
    shared with the child after fork returns.

-   Normally, the child then reads and writes the connected socket
    and the parent closes the connected socket.


////////////////////////////////////////////////////////
// Three typical uses of fork()                       //
////////////////////////////////////////////////////////

1.  A process makes a copy of itself so that one
    copy can handle one operation while the other
    copy does another task. This is typical for network
    servers.

2.  A process wants to execute another program. Since the
    only way to create a new process is by calling fork, the
    process first calls fork to make a copy of itself, and then
    one of the copies (typically the child process) calls exec()
    to replace itself with the new program. This is typical for
    programs such as shells.

3.  Eating voids that are (typically) not composed of mostly liquid.
    Some exceptions may occur in which one wishes to use a spoon.
    This is particularly useful when the desired food tends to fall
    off of the fork(), rendering the utensil essentially useless.
    For example, with foods that are small and consumed  in large
    quantities, such as rice.



////////////////////////////////////////////////////////
// The exec() function(s)                             //
////////////////////////////////////////////////////////

-   The only way in which an executable program file on disk
    can be executed by Unix is for an existing process to call
    one of the six exec functions.

-   The differences in the six exec functions are:
        (a) whether the program file to execute is specified by a
            filename or a pathname;
        (b) whether the arguments to the new program are listed one
            by one or referenced through an array of pointers;
        (c) Whether the environment of the calling process is passed
            to the new program or whether a new environment is specified.


////////////////////////////////////////////////////////
// POSIX signal handling                              //
////////////////////////////////////////////////////////

-   A signal is a notification to a process that an event
    has occurred.

-   Signals usually occur asynchronously. By this we mean
    that a process doesn’t know ahead of time exactly when
    a signal will occur.

-   Signals can be sent:
    • By one process to another process (or to itself)
    • By the kernel to a process

-   Every signal has a disposition, which is also called
    the action associated with the signal.

-   We set the disposition of a signal by calling the
    sigaction() function.

-   We have three choices for the disposition:

        1.  We can provide a function that is called whenever a specific
            signal occurs. This function is called a signal handler and
            this action is called catching a signal.

            The two signals SIGKILL and SIGSTOP cannot be caught. Our function
            is called with a single integer argument that is the signal number
            and the function returns nothing. Its function prototype is
            therefore:

                void handler(int signo);

            For most signals, calling sigaction and specifying a function to
            be called when the signal occurs is all that is required to catch
            a signal. But we will see later that a few signals, SIGIO, SIGPOLL,
            and SIGURG, all require additional actions on the part of the
            process to catch the signal.

        2.  We can ignore a signal by setting its disposition to SIG_IGN.
            The two signals SIGKILL and SIGSTOP cannot be ignored.

        3.  We can set the default disposition for a signal by setting its
            disposition to SIG_DFL. The default is normally to terminate a
            process on receipt of a signal, with certain signals also
            generating a core image of the process in its current working
            directory. There are a few signals whose default disposition is
            to be ignored: SIGCHLD and SIGURG.


////////////////////////////////////////////////////////
// I/O Multiplexing [ select() & poll() ]             //
////////////////////////////////////////////////////////

-   I/O multiplexing is typically used in networking
    applications in the following scenarios:

    1.  When a client is handling multiple descriptors
        (normally interactive input and a network socket),
        I/O multiplexing should be used.

    2.  It is possible, but rare, for a client to handle
        multiple sockets at the same time.

    3.  If a TCP server handles both a listening socket
        and its connected sockets, I/O multiplexing is
        normally used.




////////////////////////////////////////////////////////
// THE poll() SYSTEM CALL                             //
////////////////////////////////////////////////////////

-------------------------------------------------------------------
#include <poll.h>

int poll(struct pollfd *fdarray, unsigned long nfds, int timeout);

    Returns: count of ready descriptors, 0 on timeout, −1 on error
--------------------------------------------------------------------

-   The first argument is a pointer to the first element
    of an array of structures.

        >   Each element of the array is a pollfd structure
            that specifies the conditions to be tested for a
            given descriptor, fd.

            struct pollfd {
                int fd; /* descriptor to check */
                short events; /* events of interest on fd */
                short revents; /* events that occurred on fd */
            };

-   Each of these two members is composed of one or more bits
    that specify a certain condition. The constants used to specify
    the events flag and to test the revents flag against are shown below:

       |============================================================|
       | POLLIN          Normal or priority band data can be read   |
       |------------------------------------------------------------|
       | POLLRDNORM      Normal data can be read                    |
       |------------------------------------------------------------|
       | POLLRDBAND      Priority band data can be read             |
       |------------------------------------------------------------|
       | POLLPRI         High-priority data can be read             |
       |------------------------------------------------------------|
       | POLLOUT         Normal data can be written                 |
       |------------------------------------------------------------|
       | POLLWRNORM      Normal data can be written                 |
       |------------------------------------------------------------|
       | POLLWRBAND      Priority band data can be written          |
       |------------------------------------------------------------|
       | POLLERR         Error has occurred                         |
       |------------------------------------------------------------|
       | POLLHUP         Hangup has occurred                        |
       |------------------------------------------------------------|
       | POLLNVAL        Descriptor is not an open file             |
       |============================================================|





////////////////////////////////////////////////////////
// SOCKET OPTIONS                                     //
////////////////////////////////////////////////////////

    SOL_SOCKET
    ---------------------------------------------------------------------
        SO_BROADCAST    Permit sending of broadcast datagrams • int
        SO_DEBUG Enable debug tracing • int
        SO_DONTROUTE    Bypass routing table lookup • int
        SO_ERROR        Get pending error and clear int
        SO_KEEPALIVE    Periodically test if connection still alive • int
        SO_LINGER       Linger on close if data to send linger{}
        SO_OOBINLINE    Leave received out-of-band data inline • int
        SO_RCVBUF       Receive buffer size int
        SO_SNDBUF       Send buffer size int
        SO_RCVLOWAT     Receive buffer low-water mark int
        SO_SNDLOWAT     Send buffer low-water mark int
        SO_RCVTIMEO     Receive timeout timeval{}
        SO_SNDTIMEO     Send timeout timeval{}
        SO_REUSEADDR    Allow local address reuse • int
        SO_REUSEPORT    Allow local port reuse • int
        SO_TYPE         Get socket type int
        SO_USELOOPBACK • Routing socket gets copy of what it sends • int
    IPPROTO_IP IP_HDRINCL • • IP header included with data • int
    IP_OPTIONS • • IP header options (see text)
    IP_RECVDSTADDR • • Return destination IP address • int
    IP_RECVIF • • Return received interface index • int
    IP_TOS • • Type-of-service and precedence int
    IP_TTL • • TTL int
    IP_MULTICAST_IF • • Specify outgoing interface in_addr{}
    IP_MULTICAST_TTL • • Specify outgoing TTL u_char
    IP_MULTICAST_LOOP • • Specify loopback u_char
    IP_{ADD,DROP}_MEMBERSHIP • Join or leave multicast group ip_mreq{}
    IP_{BLOCK,UNBLOCK}_SOURCE • Block or unblock multicast source ip_mreq_source{}
    IP_{ADD,DROP}_SOURCE_MEMBERSHIP • Join or leave source-specific multicast ip_mreq_source{}



    link_directories(${CPT_SOURCE_DIR}/include/app)

    set(APP_CLIENT_SRC
            ${CPT_SOURCE_DIR}/app/src/cpt_chat_client.c
            PARENT_SCOPE)

    set(APP_SERVER_SRC
            ${CPT_SOURCE_DIR}/app/src/cpt_chat_server.c
            PARENT_SCOPE)

    set(APP_CLIENT_HEADERS
            ${CPT_SOURCE_DIR}/app/include/cpt_chat_client.h
            PARENT_SCOPE)

    set(APP_SERVER_HEADERS
            ${CPT_SOURCE_DIR}/app/include/cpt_chat_server.h
            PARENT_SCOPE)





















































///// TO DO

1. checkout signal more. Text is confusing. need to watch a video or something.
        - return to page 139 +\- 10 pages





















